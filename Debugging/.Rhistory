pal_brew <- PAL_BREWER
}
# Color gradient for heatmap
pal_grad <- get_col_palette(pal_brew, rev = T) %>% get_col_gradient(100)
# Should rows not be sorted?
if(isFALSE(alphabetical_row)) {
df$Var <- factor(df$Var, levels = unique(df$Var))
}
# Plot
p <- ggplot(df, aes(x = group, y = Var, fill = Fold.change)) +
geom_tile() +
ggtitle(paste(plot_title)) +
labs(
title = plot_title,
caption = ifelse(!isFALSE(p_signif), "p <= 0.001 '****', 0.001 '***', 0.01 '**', 0.05 '*'", ""),
subtitle = out_dir,
x = x_lab,
y = y_lab
) +
scale_fill_gradientn(colors = pal_grad, name = paste0(ifelse(log2FC, "log2 ", ""), "FC ", ifelse(scale_FC == "none", "", scale_FC))) +
scale_x_discrete(expand = c(0, 0)) + # remove space between grid and axes
scale_y_discrete(expand = c(0, 0)) +
theme(
panel.background = element_blank(), # remove background color and lines
plot.title = element_text(colour = "black", size = font_size),
plot.subtitle = element_text(colour = "black", size = font_size / 1.5),
axis.line = element_line(colour = "black", size = line_size), # increase the axis-line thickness and change the color to blac
# Ticks
axis.ticks = element_line(colour = "black", size = line_size), # increase the tick thickness)
axis.ticks.length = unit(.25, "cm"),
# Axes labels
axis.text = element_text(colour = "black", size = font_size), # face = "bold"),
axis.text.x = element_text(margin = margin(t = 7, r = 0, b = 0, l = 0), angle = x_axis_angle, vjust = 0.5), # increase space between x axis title and labels
axis.text.y = element_text(margin = margin(t = 0, r = 7, b = 0, l = 0)),
# axes tick labels
axis.title = element_text(colour = "black", size = font_size, face = "bold"), # axes title labels
# legend
legend.text = element_text(colour = "black", size = font_size, face = "bold"),
legend.title = element_text(colour = "black", size = font_size, face = "bold"),
# legend.position = "bottom", legend.box = "vertical"
)
# Add stars if applicable
if (!isFALSE(p_signif)) {
if (p_signif == "stars") {
p <- p +
geom_text(aes(label = p_stars), size = pval_size, color = pval_color, vjust = 0.8)
}
if (p_signif == "text") {
p <- p +
geom_text(aes(label = p.value), size = pval_size, color = pval_color, vjust = 0.5)
}
}
# Save to file
if (save.to.file) {
# Graphing params
file_h <- (length(unique(df$Var)) + 7) / 4 + 2 # file width
ggsave(device = "pdf", height = file_h, limitsize = F, filename = sprintf("%s/%s_pval_FC_grid%s.pdf", out_dir, plot_title, ifelse(scale_FC == "none", "", scale_FC)), plot = p) # , height = nrow(df)*0.6, width = 4)
} else {
print(p)
}
}
make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "threshold") # outliers have been given upper limit
make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "none") # unscaled
make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "threshold") # outliers have been given upper limit
#' @param save.to.file If TRUE, save plot to file in out_dir. If FALSE, print to panel.
#' @param font_size The size of text labels plot. legend title. The size of plot title, axis text, legend text is font_size. The size of plot subtitle is font_size / 1.5.
#' @param line_size The thickness of grid lines.
#' @param alphabetical_row Logical; should the y axis be sorted alphabetically or preserve the order of df$Var?
#'
#' @return Plot object if save.to.file is FALSE.
#' @export
#'
#' @examples
#'
make_FC.pval_plot <- function(df, x_lab = "", y_lab = "", plot_title = "", out_dir = ".", p_signif = "stars", pal_brew = "RdBu",
group_name_sep = "/", trim_x = 3, pval_size = 8, pval_color = "white", log2FC = F, scale_FC = "cap_outliers", rescale_to = c(0,1),
x_axis_angle = 0, save.to.file = F, font_size = 10, line_size = 1, alphabetical_row = F) {
# Error checking
if(!scale_FC %in% c("scale_column", "scale_row", "none", "cap_outliers")){
errorCondition("Ensure scale_FC parameter in make_FC.pval_plot has value of: 'scale_column', 'scale_row', 'none', or 'cap_outliers'")
return()
}
# Apply log transformation
if (log2FC){
df$Fold.change <- log2(df$Fold.change)
}
# Apply scale to each group/Variable
if (scale_FC == "scale_column" | scale_FC == "scale_row") {
scale_by <- ifelse(scale_FC == "scale_row", "Var", "group")
# Apply scale
df$Fold.change <- ave(as.numeric(df$Fold.change), df[,scale_by], FUN = function(x) {
scales::rescale(x, to = rescale_to)
})
}
# Apply limit to outliers, upper outliers become upper limit of scale and lower becomes lower limit
if (scale_FC == "cap_outliers") {
# Find outliers (logical)
outliers <- get_outliers(df$Fold.change)
# Rescale non-outliers
unchanged <- !outliers %in% c("upper", "lower")
# df$Fold.change[unchanged] <- scales::rescale(df$Fold.change[unchanged], to = rescale_to)
# # Make outliers limit
df$Fold.change[outliers == "lower"] <- df$Fold.change[unchanged] %>% min(na.rm = T) # rescale_to[1]
df$Fold.change[outliers == "upper"] <- df$Fold.change[unchanged] %>% max(na.rm = T)  # rescale_to[2]
}
# Add stars
if (p_signif == "stars") {
df$p_stars <- pval_to_stars(df$p.value)
} else {
df$p.value <- round(df$p.value, 3)
}
# Trim x axis # alt to scale_x_discrete(labels = function(x) strtrim(x, 3))
if (!isFALSE(trim_x)) {
n_orig <- df$group %>%
unique() %>%
length()
x <- trim_each_part(df$group, trim_x = trim_x, split = group_name_sep)
n_new <- x %>%
unique() %>%
length()
if (n_orig != n_new) {
x_axis_angle <- 45
} else {
df$group <- x
}
}
# Manually order high/low/oth comparisons
e <- unique(df$group)
e <- e[!is.na(e)]
lvl_order <- c("hig/low", "hig/int", "int/low", "hig/oth", "int/oth", "low/oth")
if (all(e %in% lvl_order)) {
# If all the elements are in the vector above, order x axis according to level order
df$group <- factor(df$group, levels = lvl_order[lvl_order %in% e])
} else {
# Move "/other" to right of heatmap
other <- ifelse(isFALSE(trim_x), "other", strtrim("other", trim_x)) %>% grepl(e)
df$group <- factor(df$group, levels = c(as.character(e[!other]), as.character(e[other])))
}
# If brewer palette specified in global constants/variables, make it as default palette
if (isTRUE("PAL_BREWER" %in% ls(envir = .GlobalEnv))) {
pal_brew <- PAL_BREWER
}
# Color gradient for heatmap
pal_grad <- get_col_palette(pal_brew, rev = T) %>% get_col_gradient(100)
# Should rows not be sorted?
if(isFALSE(alphabetical_row)) {
df$Var <- factor(df$Var, levels = unique(df$Var))
}
# Plot
p <- ggplot(df, aes(x = group, y = Var, fill = Fold.change)) +
geom_tile() +
ggtitle(paste(plot_title)) +
labs(
title = plot_title,
caption = ifelse(!isFALSE(p_signif), "p <= 0.001 '****', 0.001 '***', 0.01 '**', 0.05 '*'", ""),
subtitle = out_dir,
x = x_lab,
y = y_lab
) +
scale_fill_gradientn(colors = pal_grad, name = paste0(ifelse(log2FC, "log2 ", ""), "FC ", ifelse(scale_FC == "none", "", scale_FC))) +
scale_x_discrete(expand = c(0, 0)) + # remove space between grid and axes
scale_y_discrete(expand = c(0, 0)) +
theme(
panel.background = element_blank(), # remove background color and lines
plot.title = element_text(colour = "black", size = font_size),
plot.subtitle = element_text(colour = "black", size = font_size / 1.5),
axis.line = element_line(colour = "black", size = line_size), # increase the axis-line thickness and change the color to blac
# Ticks
axis.ticks = element_line(colour = "black", size = line_size), # increase the tick thickness)
axis.ticks.length = unit(.25, "cm"),
# Axes labels
axis.text = element_text(colour = "black", size = font_size), # face = "bold"),
axis.text.x = element_text(margin = margin(t = 7, r = 0, b = 0, l = 0), angle = x_axis_angle, vjust = 0.5), # increase space between x axis title and labels
axis.text.y = element_text(margin = margin(t = 0, r = 7, b = 0, l = 0)),
# axes tick labels
axis.title = element_text(colour = "black", size = font_size, face = "bold"), # axes title labels
# legend
legend.text = element_text(colour = "black", size = font_size, face = "bold"),
legend.title = element_text(colour = "black", size = font_size, face = "bold"),
# legend.position = "bottom", legend.box = "vertical"
)
# Add stars if applicable
if (!isFALSE(p_signif)) {
if (p_signif == "stars") {
p <- p +
geom_text(aes(label = p_stars), size = pval_size, color = pval_color, vjust = 0.8)
}
if (p_signif == "text") {
p <- p +
geom_text(aes(label = p.value), size = pval_size, color = pval_color, vjust = 0.5)
}
}
# Save to file
if (save.to.file) {
# Graphing params
file_h <- (length(unique(df$Var)) + 7) / 4 + 2 # file width
ggsave(device = "pdf", height = file_h, limitsize = F, filename = sprintf("%s/%s_pval_FC_grid%s.pdf", out_dir, plot_title, ifelse(scale_FC == "none", "", scale_FC)), plot = p) # , height = nrow(df)*0.6, width = 4)
} else {
print(p)
}
}
make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "threshold") # outliers have been given upper limit
make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "none") # unscaled
make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "threshold") # outliers have been given upper limit
p <- make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "cap_outliers") # outliers have been given upper limit
#' @param save.to.file If TRUE, save plot to file in out_dir. If FALSE, print to panel.
#' @param font_size The size of text labels plot. legend title. The size of plot title, axis text, legend text is font_size. The size of plot subtitle is font_size / 1.5.
#' @param line_size The thickness of grid lines.
#' @param alphabetical_row Logical; should the y axis be sorted alphabetically or preserve the order of df$Var?
#'
#' @return Plot object if save.to.file is FALSE.
#' @export
#'
#' @examples
#'
make_FC.pval_plot <- function(df, x_lab = "", y_lab = "", plot_title = "", out_dir = ".", p_signif = "stars", pal_brew = "RdBu",
group_name_sep = "/", trim_x = 3, pval_size = 8, pval_color = "white", log2FC = F, scale_FC = "cap_outliers", rescale_to = c(0,1),
x_axis_angle = 0, save.to.file = F, font_size = 10, line_size = 1, alphabetical_row = F) {
# Error checking
if(!scale_FC %in% c("scale_column", "scale_row", "none", "cap_outliers")){
errorCondition(message = "Ensure scale_FC parameter in make_FC.pval_plot has value of: 'scale_column', 'scale_row', 'none', or 'cap_outliers'")
return()
}
# Apply log transformation
if (log2FC){
df$Fold.change <- log2(df$Fold.change)
}
# Apply scale to each group/Variable
if (scale_FC == "scale_column" | scale_FC == "scale_row") {
scale_by <- ifelse(scale_FC == "scale_row", "Var", "group")
# Apply scale
df$Fold.change <- ave(as.numeric(df$Fold.change), df[,scale_by], FUN = function(x) {
scales::rescale(x, to = rescale_to)
})
}
# Apply limit to outliers, upper outliers become upper limit of scale and lower becomes lower limit
if (scale_FC == "cap_outliers") {
# Find outliers (logical)
outliers <- get_outliers(df$Fold.change)
# Rescale non-outliers
unchanged <- !outliers %in% c("upper", "lower")
# df$Fold.change[unchanged] <- scales::rescale(df$Fold.change[unchanged], to = rescale_to)
# # Make outliers limit
df$Fold.change[outliers == "lower"] <- df$Fold.change[unchanged] %>% min(na.rm = T) # rescale_to[1]
df$Fold.change[outliers == "upper"] <- df$Fold.change[unchanged] %>% max(na.rm = T)  # rescale_to[2]
}
# Add stars
if (p_signif == "stars") {
df$p_stars <- pval_to_stars(df$p.value)
} else {
df$p.value <- round(df$p.value, 3)
}
# Trim x axis # alt to scale_x_discrete(labels = function(x) strtrim(x, 3))
if (!isFALSE(trim_x)) {
n_orig <- df$group %>%
unique() %>%
length()
x <- trim_each_part(df$group, trim_x = trim_x, split = group_name_sep)
n_new <- x %>%
unique() %>%
length()
if (n_orig != n_new) {
x_axis_angle <- 45
} else {
df$group <- x
}
}
# Manually order high/low/oth comparisons
e <- unique(df$group)
e <- e[!is.na(e)]
lvl_order <- c("hig/low", "hig/int", "int/low", "hig/oth", "int/oth", "low/oth")
if (all(e %in% lvl_order)) {
# If all the elements are in the vector above, order x axis according to level order
df$group <- factor(df$group, levels = lvl_order[lvl_order %in% e])
} else {
# Move "/other" to right of heatmap
other <- ifelse(isFALSE(trim_x), "other", strtrim("other", trim_x)) %>% grepl(e)
df$group <- factor(df$group, levels = c(as.character(e[!other]), as.character(e[other])))
}
# If brewer palette specified in global constants/variables, make it as default palette
if (isTRUE("PAL_BREWER" %in% ls(envir = .GlobalEnv))) {
pal_brew <- PAL_BREWER
}
# Color gradient for heatmap
pal_grad <- get_col_palette(pal_brew, rev = T) %>% get_col_gradient(100)
# Should rows not be sorted?
if(isFALSE(alphabetical_row)) {
df$Var <- factor(df$Var, levels = unique(df$Var))
}
# Plot
p <- ggplot(df, aes(x = group, y = Var, fill = Fold.change)) +
geom_tile() +
ggtitle(paste(plot_title)) +
labs(
title = plot_title,
caption = ifelse(!isFALSE(p_signif), "p <= 0.001 '****', 0.001 '***', 0.01 '**', 0.05 '*'", ""),
subtitle = out_dir,
x = x_lab,
y = y_lab
) +
scale_fill_gradientn(colors = pal_grad, name = paste0(ifelse(log2FC, "log2 ", ""), "FC ", ifelse(scale_FC == "none", "", scale_FC))) +
scale_x_discrete(expand = c(0, 0)) + # remove space between grid and axes
scale_y_discrete(expand = c(0, 0)) +
theme(
panel.background = element_blank(), # remove background color and lines
plot.title = element_text(colour = "black", size = font_size),
plot.subtitle = element_text(colour = "black", size = font_size / 1.5),
axis.line = element_line(colour = "black", size = line_size), # increase the axis-line thickness and change the color to blac
# Ticks
axis.ticks = element_line(colour = "black", size = line_size), # increase the tick thickness)
axis.ticks.length = unit(.25, "cm"),
# Axes labels
axis.text = element_text(colour = "black", size = font_size), # face = "bold"),
axis.text.x = element_text(margin = margin(t = 7, r = 0, b = 0, l = 0), angle = x_axis_angle, vjust = 0.5), # increase space between x axis title and labels
axis.text.y = element_text(margin = margin(t = 0, r = 7, b = 0, l = 0)),
# axes tick labels
axis.title = element_text(colour = "black", size = font_size, face = "bold"), # axes title labels
# legend
legend.text = element_text(colour = "black", size = font_size, face = "bold"),
legend.title = element_text(colour = "black", size = font_size, face = "bold"),
# legend.position = "bottom", legend.box = "vertical"
)
# Add stars if applicable
if (!isFALSE(p_signif)) {
if (p_signif == "stars") {
p <- p +
geom_text(aes(label = p_stars), size = pval_size, color = pval_color, vjust = 0.8)
}
if (p_signif == "text") {
p <- p +
geom_text(aes(label = p.value), size = pval_size, color = pval_color, vjust = 0.5)
}
}
# Save to file
if (save.to.file) {
# Graphing params
file_h <- (length(unique(df$Var)) + 7) / 4 + 2 # file width
ggsave(device = "pdf", height = file_h, limitsize = F, filename = sprintf("%s/%s_pval_FC_grid%s.pdf", out_dir, plot_title, ifelse(scale_FC == "none", "", scale_FC)), plot = p) # , height = nrow(df)*0.6, width = 4)
} else {
print(p)
}
}
p <- make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "cap_outliers") # outliers have been given upper limit
make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "none") # unscaled
make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "threshold") # outliers have been given upper limit
#' @param save.to.file If TRUE, save plot to file in out_dir. If FALSE, print to panel.
#' @param font_size The size of text labels plot. legend title. The size of plot title, axis text, legend text is font_size. The size of plot subtitle is font_size / 1.5.
#' @param line_size The thickness of grid lines.
#' @param alphabetical_row Logical; should the y axis be sorted alphabetically or preserve the order of df$Var?
#'
#' @return Plot object if save.to.file is FALSE.
#' @export
#'
#' @examples
#'
make_FC.pval_plot <- function(df, x_lab = "", y_lab = "", plot_title = "", out_dir = ".", p_signif = "stars", pal_brew = "RdBu",
group_name_sep = "/", trim_x = 3, pval_size = 8, pval_color = "white", log2FC = F, scale_FC = "cap_outliers", rescale_to = c(0,1),
x_axis_angle = 0, save.to.file = F, font_size = 10, line_size = 1, alphabetical_row = F) {
# Error checking
if(!scale_FC %in% c("scale_column", "scale_row", "none", "cap_outliers")){
errorCondition()
return("Ensure scale_FC parameter in make_FC.pval_plot has value of: 'scale_column', 'scale_row', 'none', or 'cap_outliers'")
}
# Apply log transformation
if (log2FC){
df$Fold.change <- log2(df$Fold.change)
}
# Apply scale to each group/Variable
if (scale_FC == "scale_column" | scale_FC == "scale_row") {
scale_by <- ifelse(scale_FC == "scale_row", "Var", "group")
# Apply scale
df$Fold.change <- ave(as.numeric(df$Fold.change), df[,scale_by], FUN = function(x) {
scales::rescale(x, to = rescale_to)
})
}
# Apply limit to outliers, upper outliers become upper limit of scale and lower becomes lower limit
if (scale_FC == "cap_outliers") {
# Find outliers (logical)
outliers <- get_outliers(df$Fold.change)
# Rescale non-outliers
unchanged <- !outliers %in% c("upper", "lower")
# df$Fold.change[unchanged] <- scales::rescale(df$Fold.change[unchanged], to = rescale_to)
# # Make outliers limit
df$Fold.change[outliers == "lower"] <- df$Fold.change[unchanged] %>% min(na.rm = T) # rescale_to[1]
df$Fold.change[outliers == "upper"] <- df$Fold.change[unchanged] %>% max(na.rm = T)  # rescale_to[2]
}
# Add stars
if (p_signif == "stars") {
df$p_stars <- pval_to_stars(df$p.value)
} else {
df$p.value <- round(df$p.value, 3)
}
# Trim x axis # alt to scale_x_discrete(labels = function(x) strtrim(x, 3))
if (!isFALSE(trim_x)) {
n_orig <- df$group %>%
unique() %>%
length()
x <- trim_each_part(df$group, trim_x = trim_x, split = group_name_sep)
n_new <- x %>%
unique() %>%
length()
if (n_orig != n_new) {
x_axis_angle <- 45
} else {
df$group <- x
}
}
# Manually order high/low/oth comparisons
e <- unique(df$group)
e <- e[!is.na(e)]
lvl_order <- c("hig/low", "hig/int", "int/low", "hig/oth", "int/oth", "low/oth")
if (all(e %in% lvl_order)) {
# If all the elements are in the vector above, order x axis according to level order
df$group <- factor(df$group, levels = lvl_order[lvl_order %in% e])
} else {
# Move "/other" to right of heatmap
other <- ifelse(isFALSE(trim_x), "other", strtrim("other", trim_x)) %>% grepl(e)
df$group <- factor(df$group, levels = c(as.character(e[!other]), as.character(e[other])))
}
# If brewer palette specified in global constants/variables, make it as default palette
if (isTRUE("PAL_BREWER" %in% ls(envir = .GlobalEnv))) {
pal_brew <- PAL_BREWER
}
# Color gradient for heatmap
pal_grad <- get_col_palette(pal_brew, rev = T) %>% get_col_gradient(100)
# Should rows not be sorted?
if(isFALSE(alphabetical_row)) {
df$Var <- factor(df$Var, levels = unique(df$Var))
}
# Plot
p <- ggplot(df, aes(x = group, y = Var, fill = Fold.change)) +
geom_tile() +
ggtitle(paste(plot_title)) +
labs(
title = plot_title,
caption = ifelse(!isFALSE(p_signif), "p <= 0.001 '****', 0.001 '***', 0.01 '**', 0.05 '*'", ""),
subtitle = out_dir,
x = x_lab,
y = y_lab
) +
scale_fill_gradientn(colors = pal_grad, name = paste0(ifelse(log2FC, "log2 ", ""), "FC ", ifelse(scale_FC == "none", "", scale_FC))) +
scale_x_discrete(expand = c(0, 0)) + # remove space between grid and axes
scale_y_discrete(expand = c(0, 0)) +
theme(
panel.background = element_blank(), # remove background color and lines
plot.title = element_text(colour = "black", size = font_size),
plot.subtitle = element_text(colour = "black", size = font_size / 1.5),
axis.line = element_line(colour = "black", size = line_size), # increase the axis-line thickness and change the color to blac
# Ticks
axis.ticks = element_line(colour = "black", size = line_size), # increase the tick thickness)
axis.ticks.length = unit(.25, "cm"),
# Axes labels
axis.text = element_text(colour = "black", size = font_size), # face = "bold"),
axis.text.x = element_text(margin = margin(t = 7, r = 0, b = 0, l = 0), angle = x_axis_angle, vjust = 0.5), # increase space between x axis title and labels
axis.text.y = element_text(margin = margin(t = 0, r = 7, b = 0, l = 0)),
# axes tick labels
axis.title = element_text(colour = "black", size = font_size, face = "bold"), # axes title labels
# legend
legend.text = element_text(colour = "black", size = font_size, face = "bold"),
legend.title = element_text(colour = "black", size = font_size, face = "bold"),
# legend.position = "bottom", legend.box = "vertical"
)
# Add stars if applicable
if (!isFALSE(p_signif)) {
if (p_signif == "stars") {
p <- p +
geom_text(aes(label = p_stars), size = pval_size, color = pval_color, vjust = 0.8)
}
if (p_signif == "text") {
p <- p +
geom_text(aes(label = p.value), size = pval_size, color = pval_color, vjust = 0.5)
}
}
# Save to file
if (save.to.file) {
# Graphing params
file_h <- (length(unique(df$Var)) + 7) / 4 + 2 # file width
ggsave(device = "pdf", height = file_h, limitsize = F, filename = sprintf("%s/%s_pval_FC_grid%s.pdf", out_dir, plot_title, ifelse(scale_FC == "none", "", scale_FC)), plot = p) # , height = nrow(df)*0.6, width = 4)
} else {
print(p)
}
}
make_FC.pval_plot(pval_df2, save.to.file = F, scale_FC = "threshold") # outliers have been given upper limit
# error3: paired
# Subset data frame to only column of interest
p_df <- data.frame(
case = ds$rowAnn[, CASE_ID],
box = ds$rowAnn[, rowAnn1],
value = ds$vals[, 4], stringsAsFactors = F
)
p_df <- get_duplicated_cases(p_df, col = "case", rm.NA = "value")
# In case there are a couple of cases or zero left, do not continue
if (nrow(p_df) < 2) next
# Create plot
a <- plot_indiv_paired(p_df, color_pal = color_pal,
xlab = rowAnn1, rowAnns = rowAnn1, save.to.file = F
)
# Make list of unique elements
e <- unique(as.character(p_df$box))
# Make list of combinations (order doesn't matter) for p-values
comb <- combinations(n = length(e), r = 2, v = e, repeats.allowed = F) %>% # gtools package
split(., seq(nrow(.)))
# Add stats to plot using ggpubr
## PAIRED - does not work
tryCatch({
a + stat_compare_means(paired = T, method = "wilcox", comparisons = comb, na.rm = T, label = "p.format", size = 12 / 5, bracket.size = 1)
})
## UNPAIRED - works
a + stat_compare_means(paired = F, method = "wilcox",comparisons = comb, na.rm=T, label="p.format", size = 12/5, bracket.size = 1)
plot_indiv_paired(p_df, color_pal = color_pal,
xlab = rowAnn1, rowAnns = rowAnn1, save.to.file = F
)
