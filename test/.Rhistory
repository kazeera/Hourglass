dup <- duplicated(feat_sets$params[, c(param_col, "Feature")])
!dup
rows_feat_sets
feat_sets$params
rows_feat <- !dup & feat_sets$params$Feature %in% feats
rows_feat
dup
feat_sets$params$Feature %in% feats
!dup & feat_sets$params$Feature %in% feats
interaction(ds$colAnn[, c(colAnns[2], colAnns[1])]) %in%
interaction(feat_sets$params[rows_feat, c(1, "Feature")])
colAnns[2]
colAnns[1]
interaction(ds$colAnn[, c(colAnns[1], colAnns[2])]) %in%
interaction(feat_sets$params[rows_feat, c("Feature", param_col)])
feat_sets$params[rows_feat, c("Feature", param_col)]
ds$colAnn[, c(colAnns[1], colAnns[2])]
colAnns[2]
# Subset to columns in column annotation of interest
cols_to_keep <- interaction(ds$colAnn[, c(colAnns[2], colAnns[1])]) %in%
interaction(feat_sets$params[rows_feat, c("Feature", param_col)])
cols_to_keep
# # Do not continue with analysis if the parameter and stains don't match the columns in the input data
if (sum(cols_to_keep) < 3)
errorCondition(sprintf("In get_feat_sets_ds, can't continue with %s because less than 3 columns.", feat_sets_name))
# Subset dataset object accordingly
ds_sub <- subset_dataset(ds, cols_to_keep = cols_to_keep)
# Prevents error: column order of ds$vals and ds$colAnn are not the same
if (any(rownames(ds_sub$colAnn) != colnames(ds_sub$vals))) {
errorCondition(sprintf("In get_feat_sets_ds, can't continue with %s because column names of colAnn and vals don't match.", feat_sets_name))
}
# If custom analysis order should be preserved, apply to ds_sub
if (feat_sets_order) {
# Get order from custom analysis
rows_feat_order <-
paste(feat_sets$params[rows_feat, colAnn2], feat_sets$params[rows_feat, colAnn1_custom], sep = "_")
# Get current order
colAnn_order <- paste(ds_sub$colAnn[, colAnn2], ds_sub$colAnn[, colAnn1], sep = "_")
# Get new order
new_order <- match(rows_feat_order, colAnn_order) %>%
colnames(ds_sub$vals)[.]
# Rename rows
ds_sub <- sort_dataset(ds_sub, col_order = new_order)
}
feat_sets_order=T
# If custom analysis order should be preserved, apply to ds_sub
if (feat_sets_order) {
# Get order from custom analysis
rows_feat_order <-
paste(feat_sets$params[rows_feat, colAnn2], feat_sets$params[rows_feat, colAnn1_custom], sep = "_")
# Get current order
colAnn_order <- paste(ds_sub$colAnn[, colAnn2], ds_sub$colAnn[, colAnn1], sep = "_")
# Get new order
new_order <- match(rows_feat_order, colAnn_order) %>%
colnames(ds_sub$vals)[.]
# Rename rows
ds_sub <- sort_dataset(ds_sub, col_order = new_order)
}
colAnn1
colAnns
# If custom analysis order should be preserved, apply to ds_sub
if (feat_sets_order) {
# Get order from custom analysis
rows_feat_order <-
paste(feat_sets$params[rows_feat, "Feature"], feat_sets$params[rows_feat, param_col], sep = "_")
# Get current order
colAnn_order <- paste(ds_sub$colAnn[, colAnns[2]], ds_sub$colAnn[, colAnns[1]], sep = "_")
# Get new order
new_order <- match(rows_feat_order, colAnn_order) %>%
colnames(ds_sub$vals)[.]
# Rename rows
# ds_sub <- sort_dataset(ds_sub, col_order = new_order)
}
new_order
feats
# Rename rows
ds_sub <- sort_dataset(ds_sub, col_order = new_order)
feat_sets$sets
i = 3
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
ind_feats <- feats[! feats %in% feat_sets$sets$GroupName]
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
# Combine independent features and features from indepedent
row_feats <- paste(paste(feats, collapse=","), paste(ind_feats, collapse=","), sep=",")
row_feats
i = 1
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
ind_feats <- feats[! feats %in% feat_sets$sets$GroupName]
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
# Combine independent features and features from indepedent
row_feats <- paste(paste(feats, collapse=","), paste(ind_feats, collapse=","), sep=",")
row_feats
i
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
ind_feats <- feats[! feats %in% feat_sets$sets$GroupName]
ind_feats
any(feats %in% feat_sets$sets$GroupName)
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
rm(feats)
rm(ind_feats)
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
all
# Independent features (not part of a group)
ind_feats <- all[! all %in% feat_sets$sets$GroupName]
ind_feats
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
ind_feats <- feats[! feats %in% feat_sets$sets$GroupName]
ind_feats
i = 3
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
feats
# Independent features (not part of a group)
ind_feats <- feats[! feats %in% feat_sets$sets$GroupName]
row_feats <- paste(ind_feats, collapse=",")
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
ind_feats <- all[! all %in% feat_sets$sets$GroupName]
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
row_feats <- paste(ind_feats, collapse=",")
any(all %in% feat_sets$sets$GroupName)
all
feats
rm(feats)
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
ind_feats <- all[! all %in% feat_sets$sets$GroupName]
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
row_feats <- paste(ind_feats, collapse=",")
if(any(all %in% feat_sets$sets$GroupName)){
# Combine independent features and features from indepedent
row_feats <- paste(paste(feats, collapse=","), row_feats), sep=",")
}
if(any(all %in% feat_sets$sets$GroupName)){
# Combine independent features and features from indepedent
row_feats <- paste(paste(feats, collapse=","), row_feats, sep=",")
}
row_feats
all
ind_feats
row_feats <- paste(ind_feats, collapse=",")
if(any(all %in% feat_sets$sets$GroupName)){
# Combine independent features and features from indepedent
row_feats <- paste(paste(feats, collapse=","), row_feats, sep=",")
}
row_feats
all
i = 1
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
ind_feats <- all[! all %in% feat_sets$sets$GroupName]
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
row_feats <- paste(ind_feats, collapse=",")
if(any(all %in% feat_sets$sets$GroupName)){
# Combine independent features and features from indepedent
row_feats <- paste(paste(feats, collapse=","), row_feats, sep=",")
}
row_feats
all
i=1
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
row_feats <- paste(all[! all %in% feat_sets$sets$GroupName], collapse=",")
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
# Combine independent features and features from groups
if(any(all %in% feat_sets$sets$GroupName)){
row_feats <- paste(paste(feats, collapse=","), row_feats, sep=",")
}
row_feats
all
row_feats
i=3
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
row_feats <- paste(all[! all %in% feat_sets$sets$GroupName], collapse=",")
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
# Combine independent features and features from groups
if(any(all %in% feat_sets$sets$GroupName)){
row_feats <- paste(paste(feats, collapse=","), row_feats, sep=",")
}
row_feats
all
i=7
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
row_feats <- paste(all[! all %in% feat_sets$sets$GroupName], collapse=",")
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
# Combine independent features and features from groups
if(any(all %in% feat_sets$sets$GroupName)){
row_feats <- paste(paste(feats, collapse=","), row_feats, sep=",")
}
row_feats
all
indiv_feats
all
# Check whether any colann1/"Feature" combo is duplicated, e.g. TIMP1-Pos.Pix.Perc shows up in more than one place
# Prevents error: duplication leads to incorrect dimensions for colAnn
dup <- duplicated(feat_sets$params[, c(param_col, "Feature")])
i=7
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
# Find list of features
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
indiv_feats <- paste(all[! all %in% feat_sets$sets$GroupName], collapse=",")
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
# Combine independent features and features from groups
if(any(all %in% feat_sets$sets$GroupName)){
indiv_feats <- paste(paste(feats, collapse=","), indiv_feats, sep=",")
}
indiv_feats
all
# Check whether any colann1/"Feature" combo is duplicated, e.g. TIMP1-Pos.Pix.Perc shows up in more than one place
# Prevents error: duplication leads to incorrect dimensions for colAnn
dup <- duplicated(feat_sets$params[, c(param_col, "Feature")])
rows_feat <- !dup & feat_sets$params$Feature %in% indiv_feats
# Parameter column
param_col <- paste(std.or.alt, "Parameter", sep="_")
# Subset to columns in column annotation of interest
cols_to_keep <- interaction(ds$colAnn[, c(colAnns[2], colAnns[1])]) %in%
interaction(feat_sets$params[rows_feat, c("Feature", param_col)])
# # Do not continue with analysis if the parameter and stains don't match the columns in the input data
if (sum(cols_to_keep) < 3)
errorCondition(sprintf("In get_feat_sets_ds, can't continue with %s because less than 3 columns.", feat_sets_name))
# Subset dataset object accordingly
ds_sub <- subset_dataset(ds, cols_to_keep = cols_to_keep)
indiv_feats
interaction(ds$colAnn[, c(colAnns[2], colAnns[1])])
interaction(feat_sets$params[rows_feat, c("Feature", param_col)])
feat_sets$params$Feature %in% indiv_feats
indiv_feats
rows_feat <- !dup & feat_sets$params$Feature %in%  unlist(strsplit(indiv_feats, split = ","))
rows_feat
# Check whether any colann1/"Feature" combo is duplicated, e.g. TIMP1-Pos.Pix.Perc shows up in more than one place
# Prevents error: duplication leads to incorrect dimensions for colAnn
dup <- duplicated(feat_sets$params[, c(param_col, "Feature")])
dup
rows_feat <- !dup & feat_sets$params$Feature %in%  unlist(strsplit(indiv_feats, split = ","))
rows_feat
# Find logical vector of rows to keep
rows_feat <- !dup & feat_sets$params$Feature %in%  unlist(strsplit(indiv_feats, split = ","))
# Parameter column
param_col <- paste(std.or.alt, "Parameter", sep="_")
# Subset to columns in column annotation of interest
cols_to_keep <- interaction(ds$colAnn[, c(colAnns[2], colAnns[1])]) %in%
interaction(feat_sets$params[rows_feat, c("Feature", param_col)])
# # Do not continue with analysis if the parameter and stains don't match the columns in the input data
if (sum(cols_to_keep) < 3)
errorCondition(sprintf("In get_feat_sets_ds, can't continue with %s because less than 3 columns.", feat_sets_name))
# Subset dataset object accordingly
ds_sub <- subset_dataset(ds, cols_to_keep = cols_to_keep)
sum(cols_to_keep)
cols_to_keep
# Prevents error: column order of ds$vals and ds$colAnn are not the same
if (any(rownames(ds_sub$colAnn) != colnames(ds_sub$vals))) {
errorCondition(sprintf("In get_feat_sets_ds, can't continue with %s because column names of colAnn and vals don't match.", feat_sets_name))
}
# If custom analysis order should be preserved, apply to ds_sub
if (feat_sets_order) {
# Get order from custom analysis
rows_feat_order <-
paste(feat_sets$params[rows_feat, "Feature"], feat_sets$params[rows_feat, param_col], sep = "_")
# Get current order
colAnn_order <- paste(ds_sub$colAnn[, colAnns[2]], ds_sub$colAnn[, colAnns[1]], sep = "_")
# Get new order
new_order <- match(rows_feat_order, colAnn_order) %>%
colnames(ds_sub$vals)[.]
# Rename rows
ds_sub <- sort_dataset(ds_sub, col_order = new_order)
}
# Return result as list
list(
feat_sets_name = feat_sets_name,
ds = ds_sub,
colAnns = colAnns
)
feat_sets$sets$Alternative
isTRUE(feat_sets$sets$Alternative)
isTRUE(feat_sets$sets$Alternative[i]))
(isTRUE(feat_sets$sets$Alternative[i]))
#' Subset dataset for custom analysis
#'
#' Get a subset of dataset list object from custom analysis table
#'
#' @inheritParams run_comparison
#' @param i Row number in feat_sets$sets.
#' @param std.or.alt string, specifies to use either "Standard" or "Alternative" parameters.
#' @param feat_sets_order Logical, should we preserve feat_sets order?
#' @return A list object specifying: ds, colAnns, feat_sets_name (name of custom analysis)
#' @export
subset_feat_sets_ds <- function(ds, feat_sets, i, colAnns, std.or.alt = "Standard", feat_sets_order = T) {
# Name of analysis
feat_sets_name <- feat_sets$sets[i, 1]
if(std.or.alt == "Alternative")
feat_sets_name <- paste0(feat_sets_name, "_alt")
# Find list of features ---
# This line splits the features into a vector: eg. "1,2,3,4" turns into "1" "2" "3" "4"
all <- feats <- strsplit(feat_sets$sets[i, 2], split = ",") %>% unlist()
# Independent features (not part of a group)
indiv_feats <- paste(all[! all %in% feat_sets$sets$GroupName], collapse=",")
# Find features of each group recursively
while(any(feats %in% feat_sets$sets$GroupName)){
true <- feats %in% feat_sets$sets$GroupName
# Match group names to features
feats <- suppressMessages(plyr::mapvalues(feats[true], from=feat_sets$sets$GroupName, to=feat_sets$sets$GroupList))
# Split strings by commas
feats <- strsplit(feats, split = ",") %>% unlist()
}
# Combine independent features and features from groups
if(any(all %in% feat_sets$sets$GroupName)){
indiv_feats <- paste(paste(feats, collapse=","), indiv_feats, sep=",")
}
# Check whether any colann1/"Feature" combo is duplicated, e.g. TIMP1-Pos.Pix.Perc shows up in more than one place
# Prevents error: duplication leads to incorrect dimensions for colAnn
dup <- duplicated(feat_sets$params[, c(param_col, "Feature")])
# Find logical vector of rows to keep
rows_feat <- !dup & feat_sets$params$Feature %in%  unlist(strsplit(indiv_feats, split = ","))
# Parameter column
param_col <- paste(std.or.alt, "Parameter", sep="_")
# Subset to columns in column annotation of interest
cols_to_keep <- interaction(ds$colAnn[, c(colAnns[2], colAnns[1])]) %in%
interaction(feat_sets$params[rows_feat, c("Feature", param_col)])
# # Do not continue with analysis if the parameter and stains don't match the columns in the input data
if (sum(cols_to_keep) < 3)
errorCondition(sprintf("In get_feat_sets_ds, can't continue with %s because less than 3 columns.", feat_sets_name))
# Subset dataset object accordingly
ds_sub <- subset_dataset(ds, cols_to_keep = cols_to_keep)
# Prevents error: column order of ds$vals and ds$colAnn are not the same
if (any(rownames(ds_sub$colAnn) != colnames(ds_sub$vals))) {
errorCondition(sprintf("In get_feat_sets_ds, can't continue with %s because column names of colAnn and vals don't match.", feat_sets_name))
}
# If custom analysis order should be preserved, apply to ds_sub
if (feat_sets_order) {
# Get order from custom analysis
rows_feat_order <-
paste(feat_sets$params[rows_feat, "Feature"], feat_sets$params[rows_feat, param_col], sep = "_")
# Get current order
colAnn_order <- paste(ds_sub$colAnn[, colAnns[2]], ds_sub$colAnn[, colAnns[1]], sep = "_")
# Get new order
new_order <- match(rows_feat_order, colAnn_order) %>%
colnames(ds_sub$vals)[.]
# Rename rows
ds_sub <- sort_dataset(ds_sub, col_order = new_order)
}
# Return result as list
list(
feat_sets_name = feat_sets_name,
ds = ds_sub,
colAnns = colAnns
)
}
rm(feat_sets_name)
rm(feat_sets_order)
rm(feats)
rm(indiv_feats)
# Subset dataset
res <- subset_feat_sets_ds(ds, feat_sets, i, colAnns, std.or.alt)
std.or.alt
res
dim(res)
lapply(res, dim)
lapply(res$ds, dim)
colAnns
View(run_paired_analysis)
View(run_hourglass)
View(run_hourglass)
comparisons
xl_file
# User options file
xl_file <- "220118_UserOptions.xlsx"
get_nth_part(xl_file,"///", 1)
get_nth_part("sda/adsd/adsda","///", 1)
get_nth_part("sda/adsd/adsda","..\\/", 1)
get_nth_part("sda/adsd/adsda",".\/", 1)
get_nth_part("sda/adsd/adsda","/", 1)
# out_dir <-
xl_file = "fad"
ifelse(grepl("/", xl_file), get_nth_part(xl_file,"/", 1), ".")
# out_dir <-
xl_file = "fad/52534/453"
ifelse(grepl("/", xl_file), get_nth_part(xl_file,"/", 1), ".")
# Get output folder
out_dir <- ifelse(grepl("/", xl_file), get_nth_part(xl_file,"/", 1), ".")
gsub("/.*","",xl_file)
gsub("*./","",xl_file)
xl_file
sub("/[^/]+$", "", xl_file)
xl_file = "adsas/dadsd/adasd/adsdad/dasd"
gsub("*./","",xl_file)
sub("/[^/]+$", "", xl_file)
# Get output folder
out_dir <- ifelse(grepl("/", xl_file), sub("/[^/]+$", "", xl_file), ".")
xl_file = "1/2/3/4/5"
gsub("*./","",xl_file)
sub("/[^/]+$", "", xl_file)
